Massive thanks to the Linux Foundation for offering: LFS101x (Introduction to Linux)
// Date: 02 June 2020
// LinuxFoundation (All credits to them) in partnership with Edx


-----------------
Chapter 1 Summary
-----------------
- The Linux Foudation is the umbrella organization for several open-source projects
  Like Linux, and its work today extends far beyond that to every layer of the software stack
- The 3 major distribution families within Linux are:
    - Red Hat
    - SUSE
    - Debian
 
    
-----------------
Chapter 2 Summary
-----------------
- Linux is heavily influenced by UNIX
- Linux accesses many features and services through files, and file-like objects
- Linux is fully multi-tasking, multi-user OS, with built-in networking and service processes known as daemons
- Linux is developed by collaboration of developers around the world, with Linus Torvalds at the head.
  Technical Skill and a desire to contribute are the only qualification for participating.
- Common terms used in Linux are:
    - Kernel
    - Distribution
    - Boot loader
    - Service
    - Filesystem
    - X Window system
    - desktop
    - environment
    - command line
- A full Linux distro consists of a kernel and several other packages for file-related operations, user management, and software package management.

-----------------
Chapter 3 Summary
-----------------
- A partition is a logical volume of the disk.
- A filesystem is a method of storing/finding files on a hard disk.
- Dividing the hard disk into partitions enables data to be grouped and separated as needed.
  When a failure or mistake occurs, only the data in the affected partition will be damaged while data elsewhere will likely survive.
- The boot process starts with the: 1) BIOS                (initialization of hardware - also called POST)
  which triggers the              : 2) Boot loader         (Master Boot Record (MBR) searches for partition table then boot loader, like GRUB, for booting OS)
  to startup the                  : 3) Linux Kernel        (Kernel is loaded, and takes control in RAM. It is uncompressed, then initializes any built-in device drivers)
  Which invokes the               : 4) initramfs | initrd  (Contains binary files and programs that perform all actions needed to mount proper root filesystem.)
  Which triggers                  : 5) init program        (Handles mounting and pivoting over the final real root filesystem)


-----------------
Chapter 4 Summary
-----------------
- GNOME is a popular desktop environment and GUI that runs on top the Linux OS
- The default display manager is 'gdm': ~> sudo systemctrl start|restart|stop gdm
- The Display manger handles:
    - Display management : (Keeps track of the displays)
    - X server           : (Provides graphical services to applications, called X Clients) | being replaced by Wayland | use :~> : startx
    - Graphical logins   : (Handles graphical logins, and appropriate desktop environments after login)
- Nautilus gives three format to view files:
    - Ctrl-F   : (search box)
    - Ctrl-L   : (specific directory)
    - Combine
- Deleting a file in Nautilus will automatically move the deleted files to the : ~> : cd '.local/share/Trash/files/'
- Latest modified file can be viewed under : ~> : var/log
- gedit is the default GNOME editor


-----------------
Chapter 5 Summary
-----------------
- Access gnome-tweaks using Alt + F2
- The X server, which provides the GUI, uses : ~> : cd /etc/X11/xorg.conf (if it exists, this is only present in modern Linux distros under unusual circumstances)
- Linux uses Universal Coordinated Time (UTC) for its own internal time keeping, (Also look for CMOS bios)
- Network Time Protocal (NTP) is hte most reliable protocol for setting the local time by consulting internet servers. :~> : cd /etc/ntp.conf
- Network Manager handles network configuration files, and makes it easier and more uniform across distros.
- For Wired connections, the hardware interface and signal are automatically detected and the Network Manager sets the network settings using DHCP
  For static configurations that do not use DHCP, manual setup can be done easily through Network Manager. 
  The Media Access Control (MAC) is the unique hex number of the network card.
  For wireless networks, you can view the list of available wireless networks and see which one you are connected to using Network Manager.
  VPN connections are also supported, including native IPSec, Cisco OpenConnect, Microsoft PPTP, OpenVPN
- For the Debian family system, the package management system is:
    - dpkg  : (Debian Package) - low level
    - apt   : (Advanced Package Tool) - high level
- For the Red Hat family system, it is:
    - rpm   : (Red Hat Package Manager) - low level
    - yum | dnf | zypper | PackageKit - high level
- For OpenSUSE, it is:
    - rpm
    - YaST
    
    
-----------------
Chapter 6 Summary
-----------------
- Linux supports several web browsers including Firefox, Chrome, Epiphany, Brave, w3m, lynx, etc
- Linux supports graphical email clients like Thunderbird, Evolution, Claws Mail, and text mode email clients like Mutt, and mail.
- Linux systems also support Filezilla, XChat, Pidgin, etc
- Linux offers LibreOffice
- Linux offers GNU Image Manipulation Program (GIMP) which is like Photoshop
- Linux offers suits of development applications and tools, like compilers and debuggers
- Linux offers sound players like Amarok, Audacity, Rhythmbos, and Spotify among others
- Linux offers movie players including VLC, Plex, MPlayer, Xine, Totem, etc
- Linux offers movie editors including Kino, Cinepaint, Blender, etc
- Other graphical utilities includ eog, Inkscape, convert, Scribus, etc


-----------------
Chapter 7 Summary
-----------------
- Virtual Terminals (VT) are console sessions that use the entire display and keyboard outside of a graphical environment.
  They are considered "virtual" because, although there can be multiple active terminals, only one terminal remains visible at a time.
  One VT is reserved for the graphical enviroment. (Ubuntu uses VT 7)
  The VTs can be accessed using : ~> : Ctrl-Alt-F[2-7]
  To go back to your home VT: ~> : Ctrl-Alt-F2
- A terminal emulator program on a graphical desktop works by emulating a terminal within a window on the desktop.
  Access the gnome-terminal by doing : ~> : Alt-F2 and then type 'gnome-terminal'
  Other terminal programs include: xterm, rxvt, konsole (default on KDE), terminator
- The Graphical desktop can be switched on and off with systemctl utility or telinit:
    - : ~> sudo systemctl stop gdm          : (or sudo telinit 3)
    - : ~> sudo systemctl start|restart gdm : (or sudo telinit 5)
- Basic Command line utilities:
    - cat   : (used to type out a file or combine files)
    - tac   : (used to lokk at a file backwards, starting with last line)
    - head  : (used to show the first few lines of a file, default -n 10)
    - tail  : (used to show the last few lines of a file, changed be flagged with -n 15)
    - less  : (same as cat, but with scrolling, and search options with / or ?)
    - man   : (used to view documentation)
- Most input lines entered at the shell prompt has 3 basic elements:
    - Command
    - Options
    - Arguments
- Sudo (stands for Superuser do) allows users to run programs using the security priviledges of root, or another user
- Setting up and running sudo:
    - : ~> su (Enter)
    - : ~> su Password: #
    - : ~> echo "myusername ALL=(ALL) ALL" > /etc/sudoers.d/myusername  : (Create config file in /etc/sudoers.d)
    - : ~> chmod 440 /etc/sudoers.d/myusername : (Change permissions for smooth operations)
- Loggin In and Out
    - An available text terminal will prompt for a username (with string login:) and password
    - Nothing is displayed on the terminal when typing in the password to prevent others from seeing it
    - You can also connect and log into remote systems by using SSH (Secure Shell)
    - To do so, type ~> ssh example@remote-server.com
    - SSH connects to the remote machine, giving a command line terminal window, verifying identity using either password or crytographic key
- Shutdown
    - : ~> sudo shutdown -h 10:00 "Shutting down for scheduled maintance"
    - : ~> tldr shutdown : (for more commands)
- Locating Applications
    - which diff     ~> /usr/bin/diff  : ('which' locates exact source, 'whereis' locates source and man files, broader range of sys dir)
    - whereis diff   ~> diff: /usr/bin/diff  /usr/share/man/man1/diff.1.gz  /usr/share/man/man1p/diff.1p.gz
- Accessing directories
    - : ~> pwd        : (Displays present working directory)
    - : ~> cd ~       : (Changes to home directory, same as only : ~> cd)
    - : ~> cd ..      : (Change to parent directory ..)
    - : ~> cd -       : (Change to previous directory (- (minus))
    - : ~> pushd dir1 : (For remembering more than one directory, pushd pushes the pwd onto a stack)
    - : ~> popd dir1  : ("popd" can then used to retrieve the directory pushd on the stack) The list of dirs : ~> dirs
- Paths
    - Absolute pathname : (begin with root dir and follows the tree, branch by branch until it reaches desired dir or file) Always start with: /
    - Relative pathname : (starts from present working directory) Never starts with: /
        - ie : ~> cd /usr/bin      : (Absolute path)
        - ie : ~> cd ../../usr/bin : (Relative path)
- Exploring Filesytem
    - : ~> cd /  : (Changes your current dir to the root (/) dir)
    - : ~> ls    : (list contents of pwd)
    - : ~> ls -a : (list all files, including hidden files and directories)
    - : ~> tree  : Displays a tree view of the filesystem
- Symbolic Links
    - Symbols links (hard and soft links) are extremely useful in Linux, for creating shortcuts and saving diskspace
        - ln file1 file2    : (Creates a hard link)
        - ln -s file1 file3 : (Creates a soft link)
- Touch
    - Touch is often used to access, change and "modify times" of files. By default, it creates a file's timestamp to match current time.
    - : ~> touch <filename>
    - : ~> touch -t 202012312242 myfile (sets my file datestamp to 12/31/2020, 22:42
- Make and remove directory
    - : ~> mkdir exampledir  : (Creates exampledir with pwd as parent dir) Use -p flag to create recursively
    - : ~> rmdir exampledir  : (Will only work if "exampledir" is empty)
    - : ~> rm -rf exampledir : (Remove recursively)
- Moving, renaming, removing file
    - : ~> mv    : (rename or move a file to another location, while possible changing its name at the same time)
    - : ~> rm    : (remove a file) -f flag for forcefully removing it, -i flag for interatively removing it
- Command Line Prompt
    - : ~> echo $PS1         : \$ (Consider customzing PS1 prompt for adding functionality)
    - : ~> PS1 = "%n $(shrink_path -f)"
- Standard File Streams
    - When commands are executed, there are 3 standard file streams always open for use:
        - stdin   0    keyboard
        - stdout  1    terminal
        - stderr  2    log file
- IO Redirection
    - Through the shell command, we can redirect the three standard file streams:
        - : ~> do_something < input-file            : (Send (output of) the input file to (the input of) do_something)
        - : ~> do_something > output-file           : (Send (output of) do_something to (the input of) output-file)
        - : ~> do_something 2> error-file           : (Send (stderr of) do_something to (the input of) error-file
        - : ~> do_something > all-output-files 2>&1 : (Send anything written to a file descriptor 2(stderr) to the same place as file descriptor 1
        - : ~> do_something >& all-outpout-file     : (Easier syntax of above)
- Pipes
    - The Linux philosophy is to have many simple and short commands cooperate togethe to produce quite complex results.
    - To do so, we use pipes. You can pipe the output of one command or program into another as its input.
    - : ~> command1 | command2 | command3
- Searching for files
    - Efficiently searching for files in Linux greatly enhaces productivity:
        - : ~> locate ... 
        - : ~> find ...
    - The "locate" utility program takes advantage of "updatedb" which is a previously constructed database of files and directories.
        - : ~> locate zip | grep bin    : (grep is used to print only the lines with the specified strings, otherwise we would get a long list)
        - : ~> updatedb                 : (The database can be updated at any time fro the command line as root user)
    - Wildcard and Matching File names
        - : Simple answer: use regex
    - The "find" is an extremy useful utility program for a Linux sys admin. It recurses down the filesystem tree for dir(s) and locates files with matched conditions.
        - : ~> find /usr =name gcc            : (searching for files and directories named gcc)
        - : ~> find /usr -type d -name gcc    : (searching only for directories named gcc)
        - : ~> find /usr -type f -name gcc    : (searching only for files named gcc)
        Adv "find" options
        - : ~> find -name "*.swp" -exec rm {} ';'  : (find and removes all files that end in ".swp"). Use -ok instead of -exec for interactive removal.
        - : ~> find / -ctime 3                     : (find files changed in the last 3 days)    , options include -atime, -mtime , number (n) exact | -n | +n
        - : ~> find / -cmin -120                   : (find files changed in the last <120 mins) , options include -amin, -mmin   , number (n) exact | -n | +n
        - : ~> find / -size 0                      : (find files of size 0 bytes), can specify bytes(c), kilobytes(k), megabytes(M), gigabytes(G)
        - : ~> find / -size +10M -exec cmd {} ';'  : (find files greater than 10 MB in size, and run a command on those files) 
    
    

-----------------
Chapter 8 Summary
-----------------
- The main sources of Linux documentation are the:
    - man pages
        - : ~> man -f     : (same as : ~> whatis)
        - : ~> man -k     : (same as : ~> apropos)
        - : ~> man -a     : (display all pages in all chapters, one after the other), pipe with head of more succint output
    - GNU info
        - : ~> info       : (up arrows, q to quit, h for help, Enter to select menu item, n -> next node, p -> previous node, u -> up node)
    - help
        - : ~> man --help : (same as : ~> man -h), short description and quick reference, faster than "man" or "info" 
        - ~> yelp man:cat : (brings up the Graphical help systems)
    - online documentation sources (like Gentoo handbook, Ubuntu Documentation, etc)
    
-----------------
Chapter 9 Summary
-----------------
- Processes are used to perform various task on the system
- Processes can be single-threaded or multi-threaded
- Processed can be of different types, such as interative or non-interactive
    - Process type: interactive | batch | daemons | threads | kernel threads
    - The "scheduler" is a critical kernel function that constantly shifts processes on and off the CPU, sharing time to relative priority
        - When a process is in a "running" state, it means it is either currently executing instructions on a CPU, or waiting for a time slice for execution
        - All processes in this state reside on what is called a run queue; on a computer with multiple core, there is a run queue on each
        - When processes go into a "sleep" state, they are said to be sitting on a wait queue (Can also go into zombie state)
- Every process has a unique identifier (PID) to enable the OS to keep track of it:
    - PID    : (Unique Process ID number)
    - PPID   : (Parent Process ID), Process (Parent) that started this process, if parent dies, the PPID will refer to adoptive parent, which is "kthreadd" with PPID=2
    - TID    : (Thread ID number), same as PID for single-threaded process; for multi-threaded process, each thread shares the same PID, but has a unique TID
- Terminating process
    - : ~> kill -SIGKILL <pid>   : Some -SIGKILL and -9 are the same
    - : ~> kill -9 <pid>         : You can only kill your own processes, those belonging to another user are off limits, unless root
- The nice value, or niceness, can be used to set priority (-20 highest priority to +19 lowest priority)
    - : ~> ps lf                 : (display process with priority)
    - : ~> renice +5 <pid>       : (increase the niceness lowers the priority)
    - : ~> sudo renice -5 <pid>  : (only root can increase the priority by decreasing niceness)
- "ps" provides information about the current running processes
    - : ~> ps -ef                : (Displays all the processes in the system in full detail)
    - : ~> ps -eLf               : ("" with one line information of every thread - one process can contain multiple threads)
    - : ~> ps aux                : (Display all process for all users), consider piping or grep for more succint outputs
    - : ~> ps axo stat,pid,pcpu  : ("axo" allows you to specify which attributes you want to view)
    - : ~> pstree                : (Displays the processes running in the form of a tree)
- "top" gives constant real-time updates about the overall system performance, as well as info about processes running on the system
- Load average indicates the amount of utilization the system is under at particular times
    - : ~> w                     : 0.45 0.17 0.12    : last-minute-utilization 5-min-utilization 15-min-utilization
    - : ~> top                   : (Real time utilization)
        - top 1st line: how long system has been up, how man user logged on, load average
        - top 2nd line: total number of processes, number of running, sleeping, stopped, and zombie processes
        - top 3rd line: cpu time divided between users (us) and kernel (sy).
        *               Also %user-jobs niceness (ni), idle mode(id), jobs waiting(wa), hardware & software interrupts (hi, si). Steal time for VMs (st)
        - top 4th line: Physical Memory (RAM)
        - top 5th line: Swap Space
        - top Output  : PID, USER, PR, NI, VIRT, RES, SHR, S, %CPU, %MEM, TIME+, COMMAND
        Commands within top:
            - : ~> t   : (Toggle summary info rows 2 & 3)
            - : ~> m   : (Toggle memory info rows 4 & 5)
            - : ~> A   : (Sort process list by top resource consumers)
            - : ~> r   : (Renice (change priority) of process(es))
            - : ~> k   : (Kill a specific process)
            - : ~> f   : (Enter top config screen)
            - : ~> o   : (Interactively select new sort order in process list)
    - : ~> uptime
- Linux supports backgrounds and foreground processing for a job
    - : ~> sleep 100 &           : (Append '&' to another command to make it run in the background)
    - : ~> fg                    : (Bring job to foreground)
    - : ~> bg                    : (Push job to background) Use Ctrl-Z to suspend, and Ctrl-C to terminate foregrond jobs
    - : ~> jobs -l               : (Displays all jobs running in the background, -l flag adds PID)
- "at" executes any non-interactive command at a specified time
    - : ~> at now + 2 days       : (Specifies that the task needs to be completed 2 days from now)
    - :at> cat file.txt          : (Specifies task to be performed, note that PS1 changed)
    - :at> <EOT>                 : (Ctrl-D to end task)
    - : ~> atq                   : (Back to normal terminal, and use atq to view queued jobs)
- "cron" is used to schedule tasks that need to be performed at regualar intervals
    - Each line of a crontab file contain 5 + 1{command} fields
    - * * * * * {command}
    - Min Hr Day Mth WeekDay {Command}     : [0-59]Min [0-23]Hr [1-31]Day [1-12]Mth [0-6]WeekDay,(0=Sunday)
    Example:
        - create a simple task every day at 11 AM.
        - : ~> echo "0 11 * * * /tmp/myjob.sh"  > mycrontab                 : (Create a file "mycrontab" with the fields)
        - : ~> echo "#!/bin/bash" > /tmp/myjob.sh                           : (Put shebang into /tmp/myjob.sh)
        *   ~> echo "echo Hello I am running $0 at $(date) >> /tmp/myjob.sh : (Append to /tmp/myjob.sh)
        - : ~> chmod +x /tmp/myjob.sh                                       : (Make it executable)
        - : ~> crontab mycrontab                                            : (Put it into crontab)
        - : ~> crontab -l                                                   : (verify it was loaded), or : ~> cat /var/spool/cron/myusername
        - : ~> crontab -r                                                   : (Remove cronjob), if machine is NOT up at 11 AM, "anacron" will run the job another time.
- sleep
    - sleep NUMBER[suffix]       : (s for seconds, m for minutes, h for hours, d for days)
    

------------------
Chapter 10 Summary
------------------
- The filesystem starts at the root directory (/)
    - Linux supports several native filesystem types like:
        - ext3, ext4, squashfs, btrfs
    - There are also implementations of filesystems used on other os, such as:
        - Windows (ntfs, vfat)
        - SGI (xfs)
        - IBM (jfs)
        - MacOS (hfs, hfs+)
- The fileystem hierarchy standard (FHS) provides Linux developers and system admins a standard directory structure for the filesystem
    - In Linux (and Unix-like OS), "everything is a file" or treated as such
    - This means whether we are dealing with data files, docs or devices, we can interact with them throught the same kind of I/O operations
- Partitions help to segregate files according to usage, ownership, and type
- Filesystems can be mounted anywhere on the main filesystem tree at a mount point. Automatic filesystem mounting can be set up by editing /etc/fstab
    - : ~> sudo mount /dev/sda5 /home  : (mount a filesystem somewhere within the filesystem tree), basic arguments are "device node" and "mount point"
    - : ~> sudo umount /home           : (unmount the partition - command is umount, not unmount!)
    - : ~> df -Th                      : (diplays information about mounted filesystems, including filesystem type, and usage statistics)
- NFS (Network File System) is useful for sharing files and data through the network systems
    - Many system admins mount remote users' home directories on a server in order to give them access to the same files and config files across multiple client systems.
    - On the server machine, NFS uses "daemons" (built-in networking and service processes in Linux) and other system servers are started by typing:
        - : ~> sudo systemctl start nfs    : (The file : ~> cd /etc/exports  contains dirs and permission that a host is willing to share with other systems over NFS.)
        * : ~> /projects *.example.com(rw) : (This allows the dir /projects to be mounted using NFS with read & write (rw) permissions and shared with other hosts in the example.com domain)
        * : ~> exportfs -av                : (Notify Linux abt the directories that you are allowing to be remotely mounted using NFS) can also do : ~> sudo systemctrl restart nfs
        * : ~> sudo systemctl enable nfs   : (Ensure that the NFS service starts whenever the system is booted)
    - On the client machine, it is desired to have the remote filesystem automatically mounted upon system boot
        - : ~> servername:/projects /mnt/nfs/projects nfs defaults 0 0  : (an entry in the client's : ~> cd /etc/fstab  needs to be modified for this default behaviour)
        * : ~> sudo mount servername:/projects /mnt/nfs/projects        : (you can also mount the remote filesystem without a reboot or as a one-time mount directly by using "mount")
- Filesystem like /proc are called pseudo filesystems because they exist only in memory
    - : ~> mount            : (show all mounted filesystems)
    - : ~> cat /etc/fstab   : (show filesystems, excluding special filesystems required for normal operation, subset of "mount")
    - : ~> cat /proc/mounts : (This is how the utility gets its information, same as "mount" more or less)
- /root is the home directory of the root user
    - : ~> /bin             : (contains executable binaries, essentail commands used to boot the system or in single user mode, and essential commands like "cat", "cp", "ls", "mv", "ps", "rm")
    - : ~> /sbin            : (essential binaries related to system admin, such as "fsck" and "ip") (Symbolically linked together:: /sbin -> /usr/sbin   and:: /bin -> /usr/bin)
    - : ~> /proc            : (contains virtual files, that exist in memory, that permit viewing constantly changing kernel data) (Has runtime info like cpuinfo, interrupts, partitions, sys dir...)
    - : ~> /dev             : (contains device nodes, used by most hardware and software devices, except for network devices) (contains /sda1(first partition), /lp1(second printer) /random(rand nums))
    - : ~> /etc             : (home for system config files) (ie, /passwd /shadow /group for managing user account are all found there)
    - : ~> /lib /lib64      : (contain libraries for essential programs in /bin && /sbin) (Also are symbolically linked to /usr/lib) (Kernel modules are located in: ~> /lib/modules/<kernel-version-no>) 
    - : ~> /run /media /mnt : (used to temporarily mount filesystems, so called "loopback" filesystem which are files that pretend to be partitions)
    - : ~> /opt             : (optinal application software packages)
    - : ~> /sys             : (virtual pseudo-filesystem giving information about the system and the hardware, can be used to alter sys parameters and for debugging)
    - : ~> /srv             : (site-specifc data served up by the system, seldom used)
    - : ~> /tmp             : (temporary files, on some distros erased across a reboot, or may actually be ramdisk in memory)
    - : ~> /usr             : (multi-usr applications, utilities and data)
- /var may be put in its own filesystem so that growth can be contained and not fatally affect the system
    - : ~> /var/log         : (system log files)
    - : ~> /var/lib         : (packages and database files)
    - : ~> /var/spool       : (print queues)
    - : ~> /var/temp        : (temporary files)
- /boot contains the basic files needed to boot the system
    - : ~> /vimlinuz        : (Compressed linux kernel required for booting)
    - : ~> /initrd          : (initial ram filesystem, required for booting) - sometimes called ~> initramfs
    - : ~> /config          : (kernel configuration file, used for debugging and bookkeeping)
    - : ~> /System.map      : (Kernel symbol table, only used for debugging) [/grub is also found under /boot]
- /usr theoritically contains non-essential programs (not needed to initially boot system) and scripts and has some of these:
    - : ~> /usr/include     : (header file used to compile applications)
    - : ~> /usr/lib         : (libraries for programs in /usr/bin and /usr/sbin)
    - : ~> /usr/lib64       : (64-bit libraries "")
    - : ~> /usr/sbin        : (non-essential system binaries, such as system daemons)
    - : ~> /usr/share       : (shared data used by applications, generally architecture-independent)
    - : ~> /usr/src         : (source code, usually for linux kernel)
    - : ~> /usr/local       : (data and program specific to the local machine, sub-dir include /bin /sbin /lib /share /include, etc)
    - : ~> /usr/bin         : (primary directory of executable commands on the system)
- "diff" is used to compare files and directories
    - : ~> diff file1 file2 : (flags include -c, -r (recursive for dirs), -i (ignorecase), -w(ignore tab/spces), -q (quiet, only report differences), use "diff3" to compared 3 files
    - : ~> cmp file1 file2  : (use "cmp" to compare binary files, not "diff")
- "patch" is very useful in Linux. Modifications to source code, and config files are distributed with patch files,  contain the deltas or changes from old to new file vesions.
    - : ~> patch -p1 < patchfile        
    - : ~> patch originalfile patchfile : (make a patchfile using : ~> diff -Nur file1 file2 > patchfile) Then you can apply it
- File extensions in Linux do not necessariy mean that a file is of a certain type (This is very different from Windows!)
    - : ~> file <filename>  : (use the "file" utility to find information and the real nature of the files)
- "cp" is used to copy files on a local machine, while "rsync" is used to copy files from one machine to another, as well as synchronize contents
    -  Rsync is much faster than "cp" because it checks if the file being copied already exists, and avoid unnecessary modifiations, and only copies part of the files that are changed.
    -  Rsync is very efficient because only differences are transmitted over the network, one can sync the destination tree with the origin using -r
        - : ~> rsync -r project-X archive-machine:archives/project-X   : (Always test with --dry-run option first to ensure you get the results you want)
        *   ~> rsync sourcefile destinationfile
        *   ~> rsync --progress -arvxH --delete sourcedir destdir
- "gzip", "bzip2", "xz", and "zip" are used to compress files
- "tar" allows you to create or extract files from an archive file, often called a tarball. There's the additional option - compress or decompress 
- "dd" is used to make large exact copies, even of entire disk partitions, efficiently
    
