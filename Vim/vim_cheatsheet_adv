Find vim user-manual at http://vimdoc.sourceforge.net/htmldoc/usr_toc.html
(Thanks Vim and all its contributors!!)

Mode: ~> Esc  // Normal Mode
Mode: ~> i    // Insert Mode
Mode: ~> v    // visual Mode
Mode: ~> V    // Visual-line Mode
Mode: ~> CTRL-v // Visual-block Mode, press 'o' to switch to other corner, and 'O' to switch horizontally

Motion: ~> w    // moves to start of next word   : ~> W    // Ignores non-word char
Motion: ~> b    // moves to start of prev word   : ~> B    // ""
Motion: ~> e    // moves to end of current word  : ~> E    // ""
Motion: ~> ge   // moves to end of prev word     : ~> gE   // ""

Motion: ~> [count]$  // moves to the end of [count] lines
Motion: ~> f[letter]  // find first occurence of letter after cursor : ~> F[letter] // finds backwards
Motion: ~> t[letter]  // like find, but stops one char short, useful for edit!  : ~> T[letter] // ""
More  : Repeat motion with ';' for forwards ',' for backwards

Motion: ~> gg      // Go to Start of file
Motion: ~> G       // Go to End of file
Motion: ~> 33G     // moves to line 33, [number]G

Motion: ~> 50%     // moves to halfway through file, ie : ~> 90% goes near the end
Motion: ~> H       // Moves cursor to Home 'top visible part of displayed normal/edit window'
Motion: ~> M       // Moves cursor to Middle ""
Motion: ~> L       // Moves cursor to Last ""

Motion: ~> CTRL-G         // Displays location in file and file status
More  : ~> :set number    // Display line number in every line, switch off with :set nonumber
More  : ~> :set ruler     // Display cursor position in lower right corner of Vim window

Scroll: ~> CTRL-U     // Scrolls down half a screen of text (go up)
Scroll: ~> CTRL-D     // Scrolls up half a screen of text (go down)
Scroll: ~> CTRL-E     // Scroll up one line at a time
Scroll: ~> CTRL-Y     // Scroll down one line at a time
Scroll: ~> CTRL-F     // Scroll whole screen forward (except for two lines) (go down)
Scroll: ~> CTRL-B     // Scroll whole screen backward (excpet for two lines) (go up)

Motion_and_Scroll: ~> zt  // Scrolls and puts cursor line at the top
Motion_and_Scroll: ~> zz  // Scrolls and puts cursor line in the middle
Motion_and_Scroll: ~> zb  // Scrolls adn puts cursor line at the bottom

Search: ~> /include       // searches for 'include', Note .*[]^%/\?~$ have special meaning
*                         // to search for them, you must add a \ in front of them
Search: ~> /the\>         // searches for word that end in 'the'
Search: ~> /\<the         // searches for word that start in 'the'
Search: ~> /\<the\>       // searches for exact match for 'the'
More:  // Put your cursor on a word and use the '*' command. Vim will grab word under the cursor
*      // and use it as search string, note '#' searchs in the opposite direction
More:   // the '*' and '#' commands use start and end of word markers for exact matches
*       // for partial matches, use 'g*' and 'g#'
More:   // Vim uses Regex to match what to search for.

Regex: ^  // matches start of line
Regex: $  // matches end of line
Regex: .  // Matches any character, to match a dot enter \.

Marking: ~> ``       // Go back where you came from, after a motion command (jump)
Marking: ~> ms       // mark start
Marking: ~> 's       // Go to start mark, same as `s
Marking: ~> me       // mark end
Marking: ~> 'e       // Go to end mark, same as `e
More   : ~> :marks   // Get a list of marks, PS. now below are some special marks

----
----

Change: ~> cc   // changes a whole line, : ~> c$  // change till end of line  // :~> S
Delete: ~> dd   // deletes a whole line, : ~> d$  // delete till end of line  

Delete: ~> dw   // delete a word, must be at the start
Delete: ~> daw  // delete a word, whereever your cursor is in it
Delete: ~> das  // deletes a sentence, removes trailing whitespace
Delete: ~> dis  // deletes inner sentence, keeps trailing whitespace

Change: ~> cw   // change a word
Chagne: ~> caw  // change a word
Change: ~> cas  // change a sentece, removes whitespace after sentence
Change: ~> cis  // change inner sentence, keeps whitespace after sentence

Shortcut: ~> x  // stands for dl ;delete char left under cursor)
Shortcut: ~> X  // stands for dh ;delete char right ""
Shortcut: ~> D  // stands for d$ ;delete till end of line
Shortcut: ~> C  // stands for c$ ;change till end of line
Shortcut: ~> s  // stands for cl ;change one character

Replace: ~> r   // waits for you to type a character and replace the character under the cursor with it
More   : ~> [count]r  // repeats [count] times, motion operator

Repeat: ~> .  // Repeats the last change (One of the most POWERFUL commands in Vim)

Miscellaneous: ~> ~  // Change case of character under cursor, and move cursor to next character
Miscellaneous: ~> I  // Start insert mode after moving cursor to the first non-blank in line
Miscellaneous: ~> A  // Start Insert mode after moving cursor to the end of the line

----
----

Edit : ~> :edit foo.txt      // start editing another file, (current file is closed)
Edit : ~> :hide edit foo.txt // edit another file, but not write changes in current file yet, make it hidden
Write: ~> :write             // write the file

Open : ~> vim one.py two.rb three.rs // open and edit a sequence of files
Open : ~> vim -o one.py two.rb c.rs  // make vim open a window for each file, horizontally
Open : ~> vim -O one.py two.rb c.rs  // make vim open a window for each file, vertically

Next : ~> :next                      // go to next file (need to save changes first) use ! to override
Next : ~> :wnext                     // same as write + next
Where: ~> :args                      // shows one.py [two.rb] three.rs  -- at location 2/3
Back : ~> :previous                  // go back one file
Back : ~> :wprevious                 // same as write + previous
More : ~> :last                      // move to very last file in the list
More : ~> :first                     // move to very first file in the list

Auto : ~> :set autowrite             // always write modified files, do that we don't have to :write each time
Auto : ~> :set noautowrite           // disable autowrite

Edit : ~> :args five.c six.x seven.c // redefine list of files with need to exit vim and start again
Edit : ~> :args *.txt                // used wildcard operator to open all txt or other files

Jump : ~> CTRL-^  // Quickly jump between two files back and forth after pressing :next, only works after moving to another file

Adv
Mark : ~> `"       // After jumping to another file, this takes you to the position where the cursor was when you left thefile
Mark : ~> `.       // Takes you to the position where you made the last change
*                  // As discussed previously, local (lowercase) marks can be made to a file with ms, and 's | `s (saved locally)
Mark : ~> mF       // Uppercase marks are global, here F = foo
Mark : ~> 'F       // If you are edit another file, you can do back to the original file with 'F | `F
*                  // connect mark letter with where it's placed; H for header file, M for Makefile, and C for in a C code file
Mark : ~> :marks F // see where the specific mark F is found, also with multiple arguments, ~> :marks FCP

Backup : ~> :set backup  // Vim does not by default produce a backup file, execute command to have backup
*                        // if file is data.txt, then vim will add ~ at end and name backup as data.txt~
*                        // to change ~ at end, use : ~> :setbackupext=.bak   to save as data.txt.bak
*                        // :set patchmode=.orig   to keep original file, as backup will be overwritten with each write to file
*                        // Vim will keep a copy of unchanged file under the name "data.txt.orig"

Adv, with Registers
Copy : ~> "fyas          // copy a sentence to the f register
Copy : ~> "l3Y           // copy 3 whole lines to the l register
Copy : ~> Ctrl-Vjjww"by  // yank a block of text to the b (for block) register
*                        // Now we have three pieces of text in the f, l and b registers
*                        // Edit another file, and move around and place the text with : ~> "fp
*                        // Registers can be put in any order, and as many times as we want
Cut : ~> "wdaw           // delete a word, and put in the w register

Append: ~> :write >> logfile  // when collecting lines of text in one file, 
*                             // this command write the text of the current file to the end of the "logfile"
*                             // this avoids copy the lines, edit the log file, and put them there
*                             // but we can only append to the end of the file

Read : ~> vim -R file         // starts vim in readonly mode, to avoid edit files, : ~> view file
Read : ~> vim -M file         // "" but override is not permitted unlike above, no modifiable
More : ~> :set modifiable     // remove the modifiable protection
More : ~> :set write          // remove the write protection

Filename : ~> :edit copy.c    // open an existing file containing most of what you need
Filename : ~> :saveas move.c  // save file under a new name
Filename : ~> :file move.c    // change the name of the file you are editing, but don't write the file

----
----

Window : ~> :split        // Open a new window, splits the screen into two windows
Window : ~> :split two.rs // Opens a new window, and start editing the given file
Window : ~> Ctrl-W w      // Jump between windows, same as Ctrl-W Ctrlw
Window : ~> :close        // close a window
Window : ~> :only         // close all windows, except the one ;your cursor is on
More   : ~> :new          // open a window on a new, empty file

More   : ~> :3split one.c // splits a new window with height 3
More   : ~> Ctrl-W +      // Increase size of a window
More   : ~> Ctrl-W -      // Decrease ""

Window : ~> :vsplit       // Opens a window on the left side
Window : ~> :vsplit a.c   // Opens the file a.c in the left window
Window : ~> :vnew         // Opens a new empty file in the vertical window
More   : ~> :vertical new // Use vertical command

Adv
Jump : ~> Ctrl-W h      // Move to the window on the left
Jump : ~> Ctrl-W j      // Move to the window below
Jump : ~> Ctrl-W k      // Move to the window above
Jump : ~> Ctrl-W l      // Move to the window on the right
Adv
Jump : ~> Ctrl-W t      // Move to the top window
Jump : ~> Ctrl-W b      // Move to the bottom window

Move: ~> Ctrl-W K   // Move the window to the very top, with uppercase K
Move: ~> Ctrl-W H   // Move the window to the far left
Move: ~> Ctrl-W J   // Move the window to the bottom
Move: ~> Ctrl-W L   // Move the window to the far right

All : ~> :qall       // Quit all windows, Vim will not exit if any of the windows contain unwritten cahnges
All : ~> :wall       // Write all windows
All : ~> :wqall      // Write and Quit all windows (Careful, no way to undo this command!)

(Vimdiff)
Terminal: vimdiff main.c~ main.c             // start two files side by side, showing differences between tow files
In_Vim  : ~> :edit main.c                    // edit main.c
In_Vim  : ~> :vertical diffsplit main.c~     // then make a split, and show the differences
In_Vim  : ~> :vertical diffpatch main.c.diff // patch file must contain only one patch, otherwise you will get lot of error msgs
Adv
Scroll  : ~> :noscrollbind // don't bind the scroll for changes
Jump    : ~> ]c            // Jump forward to next change
Jump    : ~> [c            // Jump backward
Adv
Update  : ~> :diffupdate   // updates highlighting in all situations, when differences or additions are made
Move    : ~> dp            // diff put,    (make changes)   make other window line as current window 
Move    : ~> do            // diff obtain, (remove changes) make current window as other window

Adv     : ~> Ctrl-W Ctrl-^     // Splits window and edits alternate file
Adv     : ~> :tag              // Jumps a tag
Adv     : ~> :stag             // Splits window and jumps to a tag

TabPages: ~> :tabedit thatfile // create a new tab page to edit "thatfile"
TabPages: ~> :tab split        // creates another copy of "thatfile" editing the same buffer
TabHelp : ~> :tab help gt      // This will show help text for "gt" in a new tab page

----
----
Here we deal with making big changes to files
----
----

Record & Playback: ~> q[register]  // start recording a macro in a register, say a as such :~> qa
Record & Playback: ~>              // type your commands
Record & Playback: ~> q            // Stop recording the macro

Exceute: ~> @[register]            // Execute @a command to cause macro to be executed
Execute: ~> 3@[register]           // Execute @a command, repeated 3 times

Register: ~> "np                   // Put the text from the n register
Register: ~> {edits}               // Change commands that are wrong. Normal edit
Register: ~> "nyy                  // Yank the corrected commands into the n register

Append_to_register: qC {append} q  // Append to the lowercase c register, to append use uppercase C otherwise overwrite
More              : "aY            // yank current line to 'a' register
More              : "AY            // yank second line and append it to the 'a' register, no overwrite

Subs: ~> :[range]su
